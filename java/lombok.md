- @Value -- the immutable variant of @Data

## @EqualsAndHansCode
`@EaualsAndHashCode` includes all the object fields by default and may cause errors with JPA.
### Error 1: Broken HashSets (and HashMaps) with `GenerationType.IDENTITY`

`GenerationType.IDENTITY` indicates JPA not to generate Id because Id will be generated by the Identity Column of database. After one object has been created, its attribute Id doesn't have a value. After persistence in database, the attribute Id has a value which has been set by database. The hash values calculated in the two phases are different, and it may cause problem by hash based collections like Hashset or Hashmap.
  
```
@Entity
@EqualsAndHashCode
public class TestEntity {

@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
@Column(nullable = false)
private Long id;
}
```
```
public int hashCode() {
   final int PRIME = 59;
   int result = 1;
   final Object $id = this.getId();
   result = result * PRIME + ($id == null ? 43 : $id.hashCode());
   return result;
}
```
And executee the following code:
```
TestEntity testEntity = new TestEntity();
Set<TestEntity> set = new HashSet<>();

set.add(testEntity);
testEntityRepository.save(testEntity);

Assert.isTrue(set.contains(testEntity), "Entity not found in the set");
```

The assertion will fail because the hash of the object testEntity is different after persistence in database.

### Error 2: Accidentally Loading Lazy Attributes
  
Calling the method hashCode() on a lazy `@OneToMany` may fetch all the entities it contains. This can easily harm the application performance, and it can also lead to a `LazyInitializationException` if it happens outside a transaction. So the Intellij plugin `jpabuddy` recommends not to use `@EqualsAndHasCode` and `@Data` for entities. Instead you can use the safe `lombok` annotations (`@Getter`, `@Setter`, `@ToString` & `@RequiredArgsConstructor`) and let `jpabuddy` generate the methods `hascode()` and `equals()`.

## @ToString
`@ToString` may also cause the error mentioned above (Accidentally Loading Lazy Attributes). But `@ToString` can bstill be used, but all the lazy fields need to be excluded with `@ToString.Exclude`, or by using `ToString(onlyExplicityIncluded = true)` on the class and `@ToString.Include` on non-lazy fields.
